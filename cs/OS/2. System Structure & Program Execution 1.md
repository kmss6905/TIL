# 2. System Structure & Program Execution 1

![스크린샷 2023-06-19 오후 2.09.22.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d721a147-ff17-4f66-9d66-b75e14a8939a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-06-19_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.09.22.png)

![스크린샷 2023-06-19 오후 2.12.57.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b7a9e5c8-2a15-4f5e-9bdd-654197b26228/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-06-19_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.12.57.png)

## CPU

CPU 는 이번에 실행해야 될 인스트럭션의 메모리 주소를 register 중에서 program couter(pc) register 가 가지고 있음. 매번 해당 instraction 만 실행하는 것. 그리고 그런 인스트럭션 중에서 io 장치를 접근하는 상황이 되면 디스크 드라이버를 통해서 cpu가 장치에게 읽어, 쓰라고 하는 명령을 하게 됨. 즉, CPU는 메모리에 있는 instruction 지시를 받아서 일을 할 뿐이다. 

timer : 특정 프로그램이 cpu 를 막기 위한 것. 사용자프로그램을 cpu에 넘겨줄 때 timer 를 세팅해놓음. cpu 는 하나의 연산을 실행 후 interuptline 체크함. timer 가 인터럽트를 걸어오면 cpu는 하던일을 멈추고, cpu의 제어권을 사용자 프로그램에서 운영체제로 자동으로 넘어간다.

### Mode bit

![스크린샷 2023-06-19 오후 2.31.10.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/55ab6223-9557-4529-a23a-aaed845402bf/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-06-19_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.31.10.png)

- 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치 필요
- Mode bit 을 통해 하드웨어적으로 두 가지 모드의 operation 지원
    - 1 : 사용자 모드 : 사용자 프로그램 수행
    - 0 : 모니터 모드(커널모드) : OS 코드 수행
    - 보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행가능한 “특권명령”으로 규정
    - Interrupt 나 Exception 발생시 하드웨어가 mode bit 을 0으로 바꿈
    - 사용자 프로그램에게 CPU를 넘기기 전에 mode bit을 1로 셋팅

### Timer

- 타이머
    - 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시킴
    - 타이머는 매 클럭 틱 때마다 1씩 감소
    - 타이머 값이 0이 되면 타이머 인터럽트 발생
    - CPU를 특정 프로그램이 독점하는 것으로부터 보호
- 타이머는 timesharing 을 구현하기 위해 널리 이용 됨
- 타이머는 현재 시간을 계산하기 위해서도 사용

### Device Controller

- I/O Device Controller
    - 해당 I/O 장치유형을 관리하는 일종의 작은 CPU
    - 제어 정보를 위해 control register, status register를 가짐
    - local buffer 를 가짐 (일종의 data register) → 이를 통해 데이터를 가짐
        - 후에 memory 로 데이터로 넘김
        - cpu 는 메인메모리, local buffer 로 접근 가능
- I/O는 실제 device 와 local buffer 사이에서 일어남
- Device Controller 는 I/O 가 끝났을 경우 **interrupt** 로 CPU 에 그 사실을 알림

<aside>
🗨️ device driver(장치구동기) 
: OS 코드 중 각 장치별 처리 루팅 → software

</aside>

<aside>
🗨️ device controller(장치제어기)
: 각 장치를 통제하는 일종의 작은 CPU → hardware

</aside>

cpu 가 인터럽트를 너무 많이 당할 수 있다.

뭔가 인풋 하나 들어오면 → interupt 걸어버림 → cpu는 os 로 넘어가서 → cpu 는 local buffer 로 부터 데이터를 메모리로 카피해서 가져온 후 → … 반복

그래서 DAM controller(Direct Access Controller) 라는 것을 하나 더 두고 있다.

### DAMController

DAM Controller는 DMA(Direct Memory Access) 기술을 이용하여 CPU 대신에 주변장치와 메모리간의 데이터 전송을 수행하는 장치이다. 이를 통해 CPU가 일을 하지 않아도 데이터를 주고 받을 수 있기 때문에, 효율적인 데이터 전송이 가능하다. 따라서 인터럽트를 일으키지 않고, 효율적이고 빠른 데이터 전송이 가능하다.

## 입출력(I/O)의 수행

- 모든 입출력 명령은 특권 명령(즉, 운영체제를 통해서만 I/O 장치에 접근할 수 있다.)
- 사용자 프로그램은 어떻게 I/O를 하는 가?
    - 시스템 콜(system call)
        - 사용자 프로그램은 운영체제에게 I/O 요청
        - 즉, 사용자 프로그램이 운영체제의 커널 함수를 호출
            - 이건 일반적인 함수랑 좀 다름
            - (중요) 내 프로그램안에서 함수 호출하는 것은 상관없지만, 실행되다가 I/O 요청을 하기 위해서 운영체제 함수를 호출 하는 것은, 그냥 메모리 주소를 바꿔서 되는 일은   아님. 복잡함. 현재 mode bit 이 1로 되어있음. 그렇다면 I/O를 하기 위해서 OS 주소로 넘어가야 한다.
                - timer , I/O controller 가 interrupt 거는 것이 아닌 프로그램이 운영체제에게 무언가를 요청하기 위해 소프트웨어 적으로 직접 interrupt 를 걸 수 있다.(=소프트웨어 인터럽트, Trap) → 이를 통해 OS 의 modebit 이 0으로 바뀜
    - trap 을 사용하여 인터럽트 벡터의 특정 위치로 이동
    - 제어권이 인터럽트 벡터가 기리키는 인터럽트 서비스 루틴으로 이동
    - 올바른 I/O 요청인지 확인 후 I/O 수행(파일이라면, 해당 파일에 접근권한이 있는 지 등등.. )
    - I/O 완료 시 제어권을 시스템콜 다음 명령으로 옮김(끝나면 hardware 인터럽트가 걸림, 다 끝났다고~)
        - IO 요청을 할 때는 소프트웨어 인터럽트를 통해서 요청을 하고 IO 다 끝나면 하드웨어 인터럽트를 통해 다 끝났다는 사실을 알림.

# 인터럽트

- 인터럽트 당한 시점의 레지스터와 program counter 를 save 한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.
- Interrupt (넒은 의미)
    - interrupt (하드 웨어 인터럽트): 하드웨어가 발생시킨 인터럽트
    - Trap(소프트웨어 인터럽트)
        - Exception: 프로그램이 오류를 범한 경우
        - System call: 프로그램이 커널 함수를 호출하는 경우

<aside>
🗨️ 인터럽트 백터 : 해당 인터럽트의 처리 루틴 주소를 가지고 있음

인터럽트 처리 루틴(Interrupt Service Routine, 인터럽트 핸들러) : 해당 인터럽트를 처리하는 커널 함수

</aside>

가령, 키보드 컨트롤러가 인터럽트를 걸어오면 키보드 버퍼에 있는 내용을 메모리로 카피하고 키보드 io를 요청한 프로세스한테 cpu를 얻을 수 있다라는 것을 표시해야할 것이고, 타이머가 인터럽트를 걸어오면 cpu를 뺏아서 다른 프로세스에 줘야할 것이다. 인터럽트의 종류가 여러개가 있는 데 그 인터럽트 종류마다 해야할 일들이 다르다. 그렇기 때문에 각각의 인터럽트의 종류마다 무슨일을 해야하는 지 운영체제 코드에 정의가 되어있다. 즉 운영체제를 만들 때 어떤 인터럽트가 들어올 때 어떤 일을 해야하는 지 미리 정의가 되어있다. 각 인터럽트 마다 처리해야될 실제 코드를 인터럽트 처리 루틴 라고 부름. 인터럽트가 들어왔ㅇ르 때 가령 1번 인터럽트 ? → 이 함수, 2번 인터럽트 → 이 함수 실행 등등 할 수 있도록 함. 이때 각 실행할 수 있도록 하는 함수의 주소를 인터럽트 백터라고 함.