# 비트 연산
&(AND), |(OR), ^(XOR), ~ (one's completion)

* & : 둘 다 1일때 -> 1 그 외는 0
* | : 적어도 하나가 1일 때 -> 1, (0 | 0) 만 0
* ^ : 둘다 같으면 0, 다르면 1
* ~ : 비트 반전


# 시프트 연산
비트의 위치를 이동시키는 시프트 연산자  
시프트 연산자는 << 또는 >> 다음에 비트를 이동 시킬 횟수를 지정함  
<<는 비트를 왼쪽으로 이동시키고, >>는 비트를 오른쪽으로 이동시킨  

비트를 오른쪽으로 이동시켰을 때 1이 들어갈 공간이 없다면 1은 사라짐
계속 비트를 오른쪽으로 이동시키면 1은 모두 사라지고 최종 결과는 0b0이 됨


## 음수표현
-10 = ~10 + 1
-S = ~S + 1

## 비트연산자 활용법 1 : idx 번째 비트 끄기

**S &= ~(1 << 1)**

10010 에서 1번째 비트를 꺼보자
(1 << 1) -> ,,,00010
~(1 << 1) -> ..11111101
10010 & 11101 = 10000

```python

s = 18 # 10010
idx = 1
s &= ~(1 << 1)
print(s) # 10000, 16\

```

## 비트연산자 황룔법 2 : idx 번째 비트 XOR 연산

**S ^= (1 << idx)**

어떤 idx 번호 xor연산을 적용해 해당 비트를 0이라면 1로 1이라면 0으로 만든다.

```python

s = 18 # 10010
idx = 0
s ^= (1 << 0)
print(s) # 10011, 19

```

## 비트연산자 활용법 3 : 최하위 켜져있는 비트 찾기
**idx = (S & -S)**

10010 의 최하위 비트는 100 '1' 0 의 '1'이다
10100 의 최하우 비ㅡ는 10'1'00 의 '1'이다

```python
S = 18;
idx = (S & -S);
print(idx) // 2


```

## 비트연산자 활용법 4 : 크기가 n인 집합의 모든 비트를 켜기
bool 배열을 대체하기 위함.
[1,0,1,0] -> 1010(2) -> 10
10이라는 하나의 숫자로 배열만큼의 역할 을 한다.

특정 n인 집합에 대해서 해당 비트를 모두 켜져있도록 ?! => [ (1 << n) - 1 ]

## 비트연산자 활용법 5 : idx 번째 비트를 켜기  

**S |= (1 << idx)**

```python

s = 18 # 10010
idx = 1
s |= (1 << 0)
print(s) # 10011, 19

```

## 비트연산자 활용법 6 : idx 번째 비트가 켜져있는 지 확인하기
**S & (1 << idx)**

```python

s = 18
idx = 0 
if s & ( 1 << idx)):
    print("해당 idx: ", idx , "가 켜져있습니다.)
else:
    print("해당 idx: ", idx , "가 커져있습니다.)

```

# 비트마스킹

불리언 배열의 역할을 하는 "하나의 숫자"를 만들어서 "비트 연산자"를 통해 탐색, 수정 등의 작업을 하는 것을 비트마스킹이라고 한다.